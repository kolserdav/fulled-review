# Анализ кода бекенда

## Дата
07.01.2022

## Исполнитель
Сергей Кольмиллер  
https://freelancehunt.com/freelancer/kolserdav.html  
https://github.com/kolserdav  
serega12101983@gmail.com  

## Введение
Задачей данного анализа кода является обзор и выявление возможных проблем архитектуры проекта и структуры кода, глазами специалиста работавшего с десятками своих и чужих проектов, в том числе неудачными, для определения возможности поиска квалифицированных исполнителей для его дальнейшей доработки. Возможность доработки есть конечно всегда, но когда в коде имеются фундаментальные проблемы и сравнивая с объемом написанного кода иногда существенная доработка или переработка проекта может оказаться дороже чем его написание с нуля.

## Объем кода
Объем кода средний, то есть нельзя сходу сказать, что проект находится в зачаточном состоянии и проще всё переписать с нуля, в таком случае, приходится работать с тем что есть.

## Архитектура проекта
_Данное описание призвано помочь войти в понимание проекта новым разработчикам_  

Проект запускается через `ts-node-dev` точкой входа является файл `src/index.ts`, который создает socket сервер для сохранения устройства и подключается к базе данных. Далее точка входа подключает файл `src/app/index.ts`, который содержит обыявление корневых узлов api, которые в свою очередь расширяются в `app/routes` где к корневым узлам апи добавляются специализированные api для каждого узла. В роутах используются валидаторы `src/app/validators` как посредники, для проверки специфических параметров, также в роутах используются посредники `src/app/middlewares`, которые непонятно чем отличаются от validators. Роуты далее по цепочке архитектуры используют специализированные контроллеры `app/controllers`, которые далее по цепочке используют специализированные сервисы `app/services`, которые уже и выполняют бизнес логику, причем некоторые контроллеры сами выполняют бизнес логику без сервисов, что ещё раз ставит вопрос - что кроме разделения кода выполняет уровень абстракции `services`!? Ещё есть служебные методы в `src/helpers` и `src/utils` и в `src/libs`, которые непонятно чем отличаются, константы расположены в `src/enums`.
### Вывод по архитектуре:
Существующая рхитектура своей излишней вложенностью повышает порог вхождения в понимание проекта, так как заметна попытка использовать практики Enterprise приложений, с модными понятиями констроллеров и сервисов, но без пояснительной записки, а также без комментариев пояснения того или иного файла (как требуется в Enterprise) от автора -  это выглядит пугающе, на первый взгляд, так как появляются подозрения, что есть моменты которые сделаны наобум (так как автор не пишет что делает этот файл и почему он здесь, можно подумать что он сам не до конца это понимает), и это может увеличить сложность поиска исполнителя. Пояснения возможно были бы не так нужны, если бы архитектура была в классическом express стиле `точка входа с роутами`->`посредники`->`обработчики`->`всомогательные методы с глобальными константами`, а тут получается `точка входа`->`роуты`->`суб роуты`->`посредники | валидаторы`->`контроллеры`->`сервисы`->`вспомогательные методы1 | вспомогательные методы2 | вспомогательные методы3 | константы (все в разных пространствах имен)`  Но это не критично и при желании разобраться можно, тем более этого уже не изменить.
#### Рекомендации по архитектуре:
- Создать файл `docs/CONTRIBUTING.md` и писать туда неочевидные моменты архитектуры, чтобы помочь новому разработчику убрать страх перед "замудренным" проектом.

## Оформление кода
Коментарии в коде отсутствуют, как минимум нет аннотаций к методам, что опять же настораживает при первом взгляде. Понятно, что опытный разработчик и так сможет понять при детальном изучении, хотя - бы по названиям методов, но отстутствие аннотаций методов, для опытного разработчика, может означать что метод не инкапсулирован (не дописан).
#### Вывод по оформлению:
Вообще коментарии бывают излишними, когда пишут очевидные вещи например: "здесь импортируем библиотеки и т.д.", но когда нет комментариев описания методов - это может свидетельствовать, что разработчик неуважает свой труд и написанные методы никак не выделяет в коде, потому что возможно у него не было опыта долгосрочной поддержки своих же проектов. Когда `getUserInfo` не всегда удобно интерпретировать, чем если бы был комментарий "получение пользователем своих данных или админом данных любого пользователя". Также описание методов помогает исключать лишние методы, дурацкий пример: `launchPigeon` метод гораздо проще понять, что он не нужен если он будет описан как "запустить голубка в небо". Особенно этот пункт актуален, когда у проекта нет квалифицированного менеджера, который способен оценивать работу программиста по коду, делая обзор его коммитов. А по коментариям и сопуствующей документации, даже не имея знаний в програмировании, можно будет вовремя заподозрить, что что-то идет не так, и возможно разработчик совсем ничего не пишет на русском, чтобы его потом не вычислили по почерку, потому что сам не уверен что у него всё под котролем. То есть нужно следить самим, что программист проявляет заботу о будущих разработчиках, а не загоняет проект в зависимость только от себя.
#### Рекомендации по оформлению
- требовать от новых разработчиков писать хотя-бы коментарии - аннотации методов, и коментарии этапов работы метода если метод работает в несколько разных операций (например: 1 получили данные пользователя для сравнения пароля, 2 изменили данные, 3 отправили письмо и.д. ). Даже если для самого разработчика это кажется итак понятным, но тут нужно заботится о том кто вновь пришел на проект и ему некогда будет читать каждую строчку чтобы понять что там происходит и принять решения хотел бы он здесь поработать, а также о себе самом, когда вернешся к проекту спустя несколько месяцев. И как минимум, это визуально отделяет методы друг от друга, а также показывает дисциплинированность разработчика и повышает доверие нового специалиста, что может отсрочить принятие им решения бросить эту головоломку и поискать задачу попроще.

### Стилизация кода
Используется tslint, но он уже умер, желательно было юзать eslint, это не в упрек автору, так как год назад tslint был ещё вроде живой. 

### Типизация кода
Обработчики запросов не типизированы на предмет проверки типов входных и возвращаемых параметров. Express, хоть и не просто, но позволяет это делать, а здесь этого нет - поэтому упущены возможности дополнительной безопасности типов в обработчиках.
Обращения к базе типизированы при помощи `mongoose`, типы моделей описаны в файлах схем `src/models`  - замечаний нет, единственное - типы никак не связаны со схемами, кроме того что они прописаны в одном файле, поэтому при изменении схемы необходимо проверять типы схем вручную.
В вспомогательных методах не типизированы выходные данные.
Сервисы также не содержат типов возвращаемых данных.
#### Вывод по типизации:
Работа с typescript в проекте на начальном уровне - "пишем на Javascript, а где ругается там как нибудь типизируем", то есть направлена не на упрощение работы с учетом предыдущего опыта, а на то чтобы этот опыт получить.
#### Рекомендации по типизации
- описывать типы для методов, с описанием не только входных, но и выходных параметров.

### Безопасность кода
На очень низком уровне, в чем это проявляется. Всомогательные методы, контроллеры, сервисы, системно никак не обрабатывают возможные ошибки. В некоторых файлах наблюдается обработка возможных исключений через try catch, но учитывая что системной обработки нет - видимо там совпало что при дев тестах вызвали исключение, а в других местах случайно не вызвали, поэтому посчитали, что и отлавливать необязательно.
Методы просто делают свое дело и возвращают, то что должны вернуть в случае если не произойдет непредвиденного исключения.
#### Вывод по безопасности:
Возможно "итак сойдет", раз протестировано и работает. Но проблема в том, что если где-то метод получит неожиданные данные, то с учетом того, что это возможное событие никак не обработано, то запрос просто повиснет, пока не отвалится по таймауту. А с учетом того, что на процесс не подвешаны обработчики для глобального отлова таких исключений, то сервер просто упадет (докер его перезапустит и с виду покажется не так страшно, хотя страшно так как в этот момент отвалятся все текущие запросы всех клиентов, а без докера после одного такого падения сервер просто перестал бы отвечать). Пункт по безопасности требует особого внимания, так как потраченные на продвижения проекта средства могут быстро пропасть, когда наплыв клиентов потенциально будет загибать сервер, так как этот момент очень слабо предусмотрен, как будто автор никогда не поддерживал серверов в продакшене.
#### Рекомендации по безопасности:
Каждый метод должен отлавливать возможные исключения и в случае выпадания ошибки возвращать например 1, а в случае успеха то - что должен. А там где его вызывают в контроллере, после вызова этого метода проверять если результат равен 1 то возвращать клиенту сообщение об ошибке, если не 1 - то продолжать выполнение логики. Особенно обработка исключений актуальна для запросов к базе данных, так как там больше шансов для отказов из-за строгой типизации данных в базе.
На данном этапе все это отлавливать нецелесообразно, но рекомендуется следить за логами и отлавливать пока хотя - бы там где это случается.

### База данных
Никак не оформлены миграции базы данных. Это когда например мы переносим сервер на другую базу, запускаем миграции они создают все нужные таблицы (в случае с Mongo коллекции). Напрашивается вывод, что коллекции создавались вручную на локальной базе, а потом возможно переносились экспортом в удаленную, но никаких файлов и тем более описания способствующего этого понимания обнаружено не было. Проблема этого пункта может вызвать до 90 процентов случаев отказа потенциальных разработчиков работы с таким проектом, так как разработчик просто не сможет локально развернуть актуально настроенную базу данных, а если не сможет локально поднять, значит и не сможет локально тестировать.
#### Рекомендации по базе данных
- попросить автора описать, как сделать миграции в новую пустую базу и разместить это описание в `README.md`. Возможно миграции не требуются, но я пробовал зарегистрировать в локальную базу, прошло Без ошибок, но в базу ничего не записалось - это беда. 

### Развертывание кода
#### Репозиторий
В репозитории 14 веток, пришлось догадаться что актуальная ветка dev. Возможно навести порядок с ветками - удалить ненужные, актуальной сделать master если нет объективных причин почему не master. Или хотя бы где-то написать что за ветки и зачем они нужны.
#### На сервере
Сейчас на сервере удалось найти только файл `docker-compose.yml`, в папке `/home/fulled`, работающий контейнер бекенда говорит, что он запущен именно из этого файла, в нем нет правил сборки образа в просто запускается из готового образа `fulled/server:dev` в репозитории в ветке dev есть файл `Dockerfile` - видно что образ собирали из него, как это делали не совсем понятно, но судя по всему собирали отдельно. Рекомендуется описать как это было всё собрано, так как подход нестандартый, обычно сборка включена в `docker-compose.yml`. Скорей всего не смогли сделать доставку кода на сервер через git (из за того что не поддерживается вход по паролю) и как-то хитро доставили его через готовый образ. Но это неочевидный способ и, чтобы понять приходится ломать голову, тоже может служить причиной отказа новых разработчиков. Даже если он локально и развернет у себя и внесет изменения, то как он потом будет это дело на сервере обновлять!? Для того кто это знает может это легко, но кто с таким вплотную не работал - загадка. 
#### Redis
Не защищен паролем, в таком случае у меня был инцидент, когда ПО контейнера майнило на процессоре.
#### Mongo
- Не защищен паролем, с учетом что база не смотрит наружу сервера - это не особо критично, при условии что доступа к серверу не будет у того, кто не должен иметь доступа к базе (риск утечки персональных данных пользователей через недобросоветных админов сервера).
- Рекомендуется пробросить порт базы из контейнера внутрь сервера, чтобы иметь возможность подключаться к базе через ssh туннель удаленно, для удобства разработчиков - наглядно видеть что происходит в базе, учитывая что есть непонимание по миграциям - это сейчас особенно актуально.

### Фронтенд
Фронтенд написан на `Vue`, я не являюсь в нем специалистом (использую React), поэтому не могу его оценить исчерпывающе.
Что бросилось в глаза:
- не используется typescript - то есть упущены возможные бонусы по безопасности типов, но это не смертельно - уж как есть, но тогда хотя бы писали бы аннотации для методов с помощью jsdoc.
- странно используются плагины, вместо подключения в виде библиотек просто включены бандлы прямо в файлы проекта. Такой подход напоминает 2000-е годы, когда писали на JQuery. Это может негативно сказаться на показателях Page speeds по части large first load js и неиспользуемый javascript код.
В целом по фронту - работает вроде неплохо. В самом коде кое-где встречаются коментарии.
Тут я рекомендаций особо не могу дать, так как для этого нужно иметь опыт с vue побольше чем у меня.

### Связка фронтенда и бекенда
API документации запросов сервера нет, предположительно запросы обсуждались между разработчиками где-то в чате. Большая часть фронтенда уже связана с бекендом, причем эта связь завязана на участников тех обсуждений. Новый разработчик фронтенда будет просить API документацию, и не каждый захочет зависеть от другого разработчика, который по обещанию заказчика будет ему описывать, что и как получать.
Рекомендуется на новые узлы запросов сервера писать `swagger.json` или хотя бы `postman.json` на худой конец хоть какое - то описание API узлов и работы с ними.

### Заключение
По мелочам много ещё чего мне не понравилось, но сейчас на фоне проблем безопасности это мелочи из разряда "где то я уже такое видел".
Вцелом нельза сказать что проект безнадежный, бывают хуже, бывают гораздо хуже. Но всё зависит от целей, если цель закрепится на том что есть, чтобы работало хотя бы то, что написано, то вполне сойдет, скрипеть но ехать будет, если следить за логами и лечить узкие места. Если в планах, добавлять что-то понемногу время от времени, тоже возможно, но желательно сначала проработать все рекомендации (Настроить доставку кода, разобраться с миграциями, проанализировать логи и отловить исключения и т.д.), чтобы не плодить проблемы как снежный ком. Если же в планах вкладывать средства в развитие проекта, то учитывая серьезные проблемы с безопасностью кода, я бы рекомендовал всё же переписать с нуля, и уже в средне-срочной перспективе это должно будет себя оправдать. И главное, на первом этапе не экономить времени на поиске разработчика. Предпочтение лучше отдавать тем кто имеет опыт, хотя бы от 2х - 3х лет в данном стеке, так как у него уже должны быть проверенные временем какие никакие наработки, а уже когда он сделает архитектуру, создаст базовые узлы, напишет API документацию, пояснительную записку для разработчиков, тогда уже можно нанимать кого-то от одного года опыта и следить, чтобы он придерживался рекомендаций своего предшественника. Понятно, что бюджет может быть ограничен для того чтобы нанять более менее опытного разработчика на стартовый этап, но тут надо понимать, что сэкономив на поиске разработчика на стартовом этапе, может оказаться, что его код и этого не стоит. Так как потом невозможно будет найти разработчика на поддержку, тот кто имеет опыт - имеет и предложение, а соответственно выберет там где придется страдать поменьше. А тот кто опыта не имеет, не откажется, даже сделает все пункты из ТЗ, но для долгой жизни проекта уже вряд ли что - то сможет сделать, так как это закладывается на этапе проектирования и постоянно поддерживается и оптимизируется.
